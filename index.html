<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" /> 
  <title>Juego Torre de Control - Tr√°fico y M√≥vil (nariz seg√∫n movimiento)</title>
  <style>
    :root{
      --header-h:64px;
      --sky:#87CEEB;
      --plane-size:28px;
      --runway-width:360px;
      --runway-height:60px;
    }
    html,body{height:100%;margin:0;font-family:Inter, Roboto, Arial, Helvetica, sans-serif;color:#07203a}
    
    /* 2. MEJORA M√ìVIL: Forzar pantalla completa y horizontal si es posible */
    @media (max-width: 900px) and (orientation: portrait) {
      /* Puedes agregar un mensaje o una capa aqu√≠ si quieres forzar la rotaci√≥n */
    }
    
    header{
      height:var(--header-h);display:flex;align-items:center;gap:10px;padding:8px 12px;
      background:linear-gradient(180deg,#ffffffcc,#f0f0f0cc);position:fixed;left:0;right:0;top:0;z-index:300;
      box-shadow:0 2px 8px rgba(0,0,0,0.08)
    }
    header button{padding:8px 10px;border-radius:8px;border:1px solid rgba(0,0,0,0.08);background:#fff;cursor:pointer}
    
    /* MODIFICADO PARA EL NUEVO CONTROL */
    #controls{display:flex;gap:12px;align-items:center;margin-left:8px}
    #controls label, #controls input{cursor:pointer;}
    
    #game{position:fixed;top:var(--header-h);left:0;right:0;bottom:0;background:var(--sky);overflow:hidden}
    #airport{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);pointer-events:none;z-index:50}
    .runway{width:var(--runway-width);height:var(--runway-height);background:linear-gradient(180deg,#333,#222);border-radius:6px;position:relative;box-shadow:0 6px 18px rgba(0,0,0,0.25)}
    .runway::before{content:'';position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:80%;height:6px;background:repeating-linear-gradient(90deg,#fff 0 12px, transparent 12px 24px);opacity:0.9}
    .runway::after{content:'Pista';position:absolute;left:50%;top:50%;transform:translate(-50%,-25px);color:#fff;font-weight:600;font-size:12px}
    #planes{position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none}

    .plane{
      position:absolute; width:var(--plane-size); height:var(--plane-size);
      transform-origin:center center; pointer-events:auto; z-index:100;
      display:flex;align-items:center;justify-content:center;overflow:visible;
    }
    .plane .icon{width:var(--plane-size);height:var(--plane-size);transition:transform 3.95s linear;transform-origin:center center;display:block}
    /* SVG de avi√≥n orientado hacia la derecha por defecto (0¬∞ = derecha) */
    .plane .tag{
      position:absolute; left:50%; top:0; transform:translate(-50%,-140%);
      white-space:nowrap; background:transparent; color:#fff; font-size:11px; text-shadow:1px 1px 2px rgba(0,0,0,0.8);
      pointer-events:none;
    }
    .plane.selected .tag{
      background:#fff7d6;color:#07203a;padding:4px 8px;border-radius:6px;box-shadow:0 4px 12px rgba(0,0,0,0.12);
    }
    .plane.warning{filter:drop-shadow(0 0 6px red)}
    .plane.danger{filter:drop-shadow(0 0 10px blue)}

    .modal{display:none;position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.5);align-items:center;justify-content:center;z-index:500}
    .card{background:#fff;padding:16px;border-radius:10px;min-width:280px;max-width:920px}
    .close{position:absolute;right:12px;top:8px;cursor:pointer;padding:6px;border-radius:6px;background:#eee}
    .statusBox{margin-left:auto;display:flex;gap:10px;align-items:center}
    .statusSmall{background:#fff;padding:6px 8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06)}
    
    /* REMOVIDO: input[type=range]{width:140px} */
    
    @media (max-width:700px){
      .plane .tag{font-size:10px}
      /* Ajuste de dise√±o en m√≥viles si es necesario */
      header{gap:4px; padding:4px 8px; flex-wrap: wrap; height: auto; position: sticky;}
      #game{top: auto; padding-top: 64px;} /* Ajusta el top de #game para que no lo tape el header envuelto */
      .statusBox{margin-left: unset; width: 100%; justify-content: space-between; margin-top: 4px;}
      #controls{margin-left:0;}
    }
  </style>
</head>
<body>
  <header>
    <button id="btnTutorial">‚ùî Tutorial</button>
    <button id="btnStart">‚ñ∂ Iniciar</button>
    <button id="btnPause">‚è∏ Pausar</button>
    <button id="btnMic">üé§</button>

    <div id="controls">
      <label>Tr√°fico:</label>
      <label><input type="radio" name="trafficLevel" value="leve" checked> Leve</label>
      <label><input type="radio" name="trafficLevel" value="medio"> Medio</label>
      <label><input type="radio" name="trafficLevel" value="fuerte"> Fuerte</label>
    </div>
    <div class="statusBox">
      <div class="statusSmall">En radar: <strong id="countRadar">0</strong></div>
      <div class="statusSmall">Aterrizados: <strong id="countLanded">0</strong></div>
      <div class="statusSmall">Seleccionado: <strong id="selName">N/A</strong></div>
    </div>
  </header>

  <div id="game">
    <div id="airport"><div class="runway"></div></div>
    <div id="planes"></div>
  </div>

  <div id="modalTutorial" class="modal" role="dialog" aria-hidden="true">
    <div class="card">
      <div class="close" id="closeTutorial">‚úï</div>
      <h3>Tutorial</h3>
      <p>Presiona Iniciar. Selecciona un avi√≥n haciendo click sobre √©l. Usa el micr√≥fono (G o bot√≥n) y di comandos como: "velocidad 150", "rumbo 90", "altitud 8000".</p>
    </div>
  </div>

  <div id="modalCollision" class="modal" role="dialog" aria-hidden="true">
    <div class="card">
      <div class="close" id="closeCollision">‚úï</div>
      <h3>Colisi√≥n detectada</h3>
      <div id="collisionDetails"></div>
    </div>
  </div>

  <script>
  /* ----------------------------------------------------------
     Versi√≥n corregida: 
     - Mantiene tu c√≥digo original (voz, colisiones, modales).
     - **MEJORA 1**: Control de tr√°fico por Checkbox (Leve, Medio, Fuerte).
     - **MEJORA 2**: Ajustes CSS para mejor visualizaci√≥n en m√≥vil (horizontal).
     - Corrige la orientaci√≥n del icono para que la **nariz** del avi√≥n 
       apunte exactamente en la direcci√≥n del movimiento (vx,vy).
     ---------------------------------------------------------- */

  // ========== CONFIG ==========
  const KNOT_TO_PPS = 0.02; // escala (puedes ajustar si quieres m√°s r√°pido)
  // BASE_SPAWN_INTERVAL es ahora solo un valor grande. El intervalo real se calcula en base al tr√°fico deseado por minuto.
  const BASE_SPAWN_INTERVAL = 60000; // 60 segundos (para calcular por minuto) 
  const AIRLINES = ["Latam","Avianca","Sky","Peruvian","Iberia","American","Delta","JetSmart","Gol"];
  const SVG_ROTATION_ADJUST = 0; // Ajuste extra si tu SVG est√° orientado distinto (0,90,-90,180)

  // elementos
  const planeContainer = document.getElementById('planes');
  const game = document.getElementById('game');
  const airport = document.getElementById('airport');
  const runway = document.querySelector('.runway');
  // REMOVIDO: const spawnRateInput = document.getElementById('spawnRate');
  // REMOVIDO: const spawnVal = document.getElementById('spawnVal');
  const countRadarEl = document.getElementById('countRadar');
  const countLandedEl = document.getElementById('countLanded');
  const selNameEl = document.getElementById('selName');

  // estado
  let planes = new Map();     // id -> plane
  let running = false;
  let lastTime = null;
  let spawnTimer = 0;
  let planeIdCounter = 1;
  let landedCount = 0;
  let recognition = null;
  let listening = false;
  let selectedPlaneId = null;

  // ========== HELPERS ==========
  function rand(min,max){ return Math.random()*(max-min)+min; }
  function choose(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function sanitizeHeading(h){ let hh = Number(h) % 360; if(isNaN(hh)) hh = 0; if(hh<0) hh+=360; return hh; }
  function formatNumber(n){ return n.toLocaleString('en-US'); }
  function extractNumber(text){
    const m = text.match(/([0-9]+(?:[.,][0-9]*)?)/);
    if(m){
      return parseInt(m[1].replace(/[.,]/g,''),10);
    }
    return null;
  }
  
  // 1. L√≥gica para calcular el intervalo seg√∫n el tr√°fico
  function calculateSpawnRate(){
    const selectedLevel = document.querySelector('input[name="trafficLevel"]:checked').value;
    let minPerMinute, maxPerMinute;

    switch(selectedLevel){
      case 'leve':
        minPerMinute = 2; maxPerMinute = 3; 
        break;
      case 'medio':
        minPerMinute = 4; maxPerMinute = 6; 
        break;
      case 'fuerte':
        minPerMinute = 7; maxPerMinute = 9; 
        break;
      default:
        return 0; // Tr√°fico nulo si no hay selecci√≥n
    }
    
    // Calcula la media deseada de aviones por minuto
    const averagePerMinute = (minPerMinute + maxPerMinute) / 2;
    
    // Calcula el intervalo promedio entre aviones en milisegundos
    // BASE_SPAWN_INTERVAL (60000ms) / averagePerMinute
    const averageIntervalMs = BASE_SPAWN_INTERVAL / averagePerMinute;
    
    // Devuelve un objeto con el intervalo promedio y el rango de aleatoriedad
    return { 
      averageIntervalMs, 
      minPerMinute, 
      maxPerMinute 
    };
  }


  // ========== VISUAL UPDATE ==========
  // Actualiza posici√≥n, texto y rotaci√≥n del icono seg√∫n VECTOR de velocidad
  function updatePlaneVisual(pl){
    if(!pl || !pl.el) return;
    // posicionar el contenedor
    pl.el.style.transform = `translate(${pl.x}px, ${pl.y}px)`;

    // calcular √°ngulo real del vector de movimiento (vx, vy)
    // si vx/vy no existen (speed 0) calcular desde heading
    let vx = pl.vx, vy = pl.vy;
    if(typeof vx !== 'number' || typeof vy !== 'number'){
      const rad = pl.heading * Math.PI / 180;
      vx = Math.cos(rad) * pl.speed * KNOT_TO_PPS;
      vy = Math.sin(rad) * pl.speed * KNOT_TO_PPS;
      pl.vx = vx; pl.vy = vy;
    }

    // atan2 devuelve √°ngulo en rad respecto al eje X (derecha = 0)
    let angleDeg = Math.atan2(vy, vx) * 180 / Math.PI;
    if(!isFinite(angleDeg)) angleDeg = pl.heading; // fallback
    // aplicar ajuste si la SVG necesita rotaci√≥n extra
    const finalAngle = angleDeg + SVG_ROTATION_ADJUST;

    const iconEl = pl.el.querySelector('.icon');
    if(iconEl){
      iconEl.style.transform = `rotate(${finalAngle}deg)`;
    }

    const tag = pl.el.querySelector('.tag');
    if(tag){
      tag.innerHTML = `${pl.name}<br>Vel ${Math.round(pl.speed)} nudos ¬∑ Rum ${Math.round(pl.heading)}¬∞ ¬∑ Alt ${formatNumber(pl.altitude)} ft`;
    }
  }

  // recalcula vx,vy a partir de heading y speed (en nudos)
  function recalcVelocity(pl){
    const rad = pl.heading * Math.PI / 180;
    pl.vx = Math.cos(rad) * pl.speed * KNOT_TO_PPS;
    pl.vy = Math.sin(rad) * pl.speed * KNOT_TO_PPS;
  }

  // ========== CREAR AVI√ìN ==========
  function createPlane(){
    const id = 'p' + (planeIdCounter++);
    const airline = choose(AIRLINES);
    const flightNum = String(Math.floor(rand(100,999)));
    const name = `${airline} ${flightNum}`;

    // spawn from edges
    const w = game.clientWidth, h = game.clientHeight;
    const edge = Math.floor(rand(0,4));
    let x,y,heading;
    if(edge === 0){ x = rand(20,w-20); y = -40; heading = rand(20,160); }          // top -> downward
    else if(edge === 1){ x = w+40; y = rand(20,h-20); heading = rand(110,250); }  // right -> leftish
    else if(edge === 2){ x = rand(20,w-20); y = h+40; heading = rand(200,340); }  // bottom -> upward
    else { x = -40; y = rand(20,h-20); heading = rand(-70,70); }                 // left -> rightish

    const speed = 120; // nudos por defecto
    const altitude = Math.floor(rand(4000,34000));

    // crear DOM (SVG orientado a la DERECHA por defecto)
    const el = document.createElement('div');
    el.className = 'plane';
    el.dataset.id = id;
    el.style.left = '0px'; el.style.top = '0px';

    el.innerHTML = `
 <div class="icon" aria-hidden="true">
  <svg viewBox="0 0 120 80" xmlns="http://www.w3.org/2000/svg">
    <rect x="10" y="34" width="90" height="12" rx="6" fill="black"/>
    
    <circle cx="100" cy="40" r="6" fill="black"/>
    
    <polygon points="10,34 4,28 4,52 10,46" fill="black"/>
    
    <polygon points="50,28 20,12 22,20 50,36" fill="black"/>
    <polygon points="50,52 20,68 22,60 50,44" fill="black"/>
    
    <ellipse cx="32" cy="26" rx="3" ry="5" fill="black"/>
    <ellipse cx="38" cy="28" rx="3" ry="5" fill="black"/>
    <ellipse cx="32" cy="54" rx="3" ry="5" fill="black"/>
    <ellipse cx="38" cy="52" rx="3" ry="5" fill="black"/>
    
    <polygon points="14,30 6,20 10,20 18,30" fill="black"/>
    <polygon points="14,50 6,60 10,60 18,50" fill="black"/>
  </svg>
</div>

      <div class="tag">${name}<br>Vel ${speed} nudos ¬∑ Rum ${Math.round(heading)}¬∞ ¬∑ Alt ${altitude} ft</div>
    `;

    planeContainer.appendChild(el);

    const plane = {
      id, name, flightNum, airline,
      x, y, heading: sanitizeHeading(heading), speed, altitude,
      vx: 0, vy: 0, el
    };

    recalcVelocity(plane);
    updatePlaneVisual(plane);

    // click -> seleccionar
    el.addEventListener('click', (ev)=>{
      selectPlane(plane.id);
      ev.stopPropagation();
    });

    planes.set(plane.id, plane);
    updateCounts();

    // peque√±a comunicaci√≥n de aproximaci√≥n
    setTimeout(()=>{
      if(planes.has(plane.id)){
        speak(`${plane.name} solicita aproximaci√≥n.`);
      }
    }, 7000);

    return plane;
  }

  // ========== SELECCI√ìN ==========
  function selectPlane(id){
    // limpiar selecci√≥n previa
    if(selectedPlaneId && planes.has(selectedPlaneId)){
      planes.get(selectedPlaneId).el.classList.remove('selected');
    }
    selectedPlaneId = id;
    if(planes.has(id)){
      const pl = planes.get(id);
      pl.el.classList.add('selected');
      selNameEl.textContent = pl.name;
      updatePlaneVisual(pl);
    } else {
      selNameEl.textContent = 'N/A';
    }
  }

  // ========== TTS ==========
  function speak(text, opts={rate:1}){
    if('speechSynthesis' in window){
      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'es-ES'; u.rate = opts.rate || 1;
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);
    } else {
      console.log('TTS:', text);
    }
  }

  // ========== BUCLE PRINCIPAL ==========
  function loop(ts){
    if(!running){ lastTime = ts; requestAnimationFrame(loop); return; }
    if(!lastTime) lastTime = ts;
    const dt = (ts - lastTime) / 1000;
    lastTime = ts;

    // 1. L√≥gica de spawn mejorada con aleatoriedad (Opci√≥n 1)
    const trafficConfig = calculateSpawnRate();
    if(trafficConfig && trafficConfig.averageIntervalMs > 0){
      const interval = trafficConfig.averageIntervalMs;
      spawnTimer += dt * 1000;
      
      if(spawnTimer > interval){
        createPlane();
        
        // Reinicio aleatorio para que no aparezcan a cadencia perfecta
        // Random offset de +/- 30% del intervalo promedio
        const randomOffset = rand(-interval * 0.3, interval * 0.3);
        spawnTimer = randomOffset; 
      }
    }
    

    // mover aviones
    const toRemove = [];
    const gameRect = game.getBoundingClientRect();
    const runwayRect = runway.getBoundingClientRect();

    planes.forEach((pl)=>{
      // asegurarse vx/vy actualizados (por si se cambiaron speed/heading)
      recalcVelocity(pl);

      // mover
      pl.x += pl.vx * dt;
      pl.y += pl.vy * dt;

      // actualizar visual
      updatePlaneVisual(pl);

      // quitar si sale mucho de la pantalla
      const margin = 160;
      if(pl.x < -margin || pl.x > game.clientWidth + margin || pl.y < -margin || pl.y > game.clientHeight + margin){
        toRemove.push(pl.id);
      }

      // Chequeo de aterrizaje: si est√° dentro del rect√°ngulo de la pista (aprox)
      // Convertir coords locales:
      const px = pl.x + gameRect.left;
      const py = pl.y + gameRect.top;
      const centerX = gameRect.left + gameRect.width / 2;
      const centerY = gameRect.top + gameRect.height / 2;
      const relX = px - centerX;
      const relY = py - centerY;
      const runwayHalfW = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--runway-width')) || 360) / 2;
      const runwayHalfH = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--runway-height')) || 60) / 2 + 20;
      const inRunwayBox = Math.abs(relX) < runwayHalfW && Math.abs(relY) < runwayHalfH;

      // Ajuste de heading para pista (rumbo 0 o 180)
      const alignedWithRunway = (Math.abs(((pl.heading+360)%360) - 180) < 15) || (Math.abs(((pl.heading+360)%360) - 0) < 15);

      if(inRunwayBox && pl.speed >= 120 && pl.altitude <= 1000 && alignedWithRunway){
        // aterriz√≥
        landedCount++;
        playLanding(pl);
        toRemove.push(pl.id);
      }
    });

    // remover aviones marcados
    toRemove.forEach(id=>{
      if(planes.has(id)){
        const p = planes.get(id);
        p.el.remove();
        planes.delete(id);
        // Si el avi√≥n removido estaba seleccionado, deseleccionar
        if(selectedPlaneId === id) selectPlane(null); 
      }
    });

    // detecci√≥n de proximidad/colisi√≥n (pairwise)
    // ================== DETECCI√ìN MEJORADA CON SONIDO ==================
    const WARNING_SOUND = new Audio(''); // tu archivo de radar
    WARNING_SOUND.volume = 0.3; // volumen bajo
    const WARNING_DIST = 60;      // p√≠xeles para advertencia
    const WARNING_ALT = 2000;     // pies de diferencia para advertencia
    const DANGER_DIST = 12;       // p√≠xeles para choque
    const DANGER_ALT = 1000;      // pies de diferencia para choque

    planes.forEach((a)=>{
      let anyNear = false; // para limpiar clase warning si ya no hay cercano
      planes.forEach((b)=>{
        if(a === b) return;
        
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        const dist = Math.sqrt(dx*dx + dy*dy);  // distancia real
        const altDiff = Math.abs(a.altitude - b.altitude);

        // choque real
        if(dist < DANGER_DIST && altDiff < DANGER_ALT){
          a.el.classList.add('danger');
          b.el.classList.add('danger');
          showCollisionModal([a,b]);
        }
        // advertencia
        else if(dist < WARNING_DIST && altDiff < WARNING_ALT){
          a.el.classList.add('warning');
          b.el.classList.add('warning');
          anyNear = true;
          
          // disparar sonido solo una vez por frame
          if(!a.warningSoundPlayed){
            WARNING_SOUND.currentTime = 0;
            WARNING_SOUND.play();
            speak(`Advertencia: 2 aviones cerca`);
            a.warningSoundPlayed = true;
          }
        }
      });

      // limpiar advertencia si ya no hay cercano
      if(!anyNear){
        a.el.classList.remove('warning');
        a.el.classList.remove('danger'); // Limpiar danger si estaba cerca pero no choc√≥
        a.warningSoundPlayed = false;
      }
    });
    // ================== FIN DETECCI√ìN MEJORADA ==================


    updateCounts();
    requestAnimationFrame(loop);
  }

  function playLanding(pl){
    speak(`${pl.name} ha aterrizado.`);
  }

  function showCollisionModal(list){
    if(!list || list.length < 2) return;
    const details = document.getElementById('collisionDetails');
    details.innerHTML = '';
    list.forEach(p=>{
      const d = document.createElement('div');
      d.style.padding = '6px 0';
      d.innerHTML = `<strong>${p.name}</strong> ‚Äî Vel ${Math.round(p.speed)} nudos ¬∑ Rum ${Math.round(p.heading)}¬∞ ¬∑ Alt ${formatNumber(p.altitude)} ft`;
      details.appendChild(d);
    });
    document.getElementById('modalCollision').style.display = 'flex';
    // pausa el juego
    running = false;
    speak('Colisi√≥n detectada.');
  }

  // ========== VOZ (SpeechRecognition) ==========
  function setupRecognition(){
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if(!SR){
      alert('Reconocimiento de voz no soportado en este navegador.');
      return null;
    }
    const r = new SR();
    r.lang = 'es-PE';
    r.interimResults = false;
    r.maxAlternatives = 1;

    r.onresult = (evt) => {
      const txt = evt.results[0][0].transcript.trim();
      console.log('Voz ->', txt);
      handleTranscript(txt);
    };
    r.onend = () => {
      listening = false;
      document.getElementById('btnMic').textContent = 'üé§';
    };
    r.onerror = (e) => {
      console.warn('Speech error', e);
      listening = false;
      document.getElementById('btnMic').textContent = 'üé§';
    };
    return r;
  }

  function toggleListening(){
    if(!recognition) recognition = setupRecognition();
    if(!recognition) return;
    if(listening){ recognition.stop(); listening=false; document.getElementById('btnMic').textContent='üé§'; }
    else { recognition.start(); listening=true; document.getElementById('btnMic').textContent='üéôÔ∏è'; }
  }

  function findPlaneByName(text){
    for(const [id,p] of planes.entries()){
      if(p.name.toLowerCase() === text.toLowerCase()) return p;
    }
    return null;
  }

  function handleTranscript(txt){
    const low = txt.toLowerCase();
    // si nombran avi√≥n exacto, seleccionar
    const maybe = findPlaneByName(txt);
    if(maybe){
      selectPlane(maybe.id); speak(`${maybe.name} seleccionado.`); return;
    }

    // comandos: velocidad, rumbo, altitud
    const n = extractNumber(low);
    if(low.includes('velocidad') || low.includes('vel')){
      if(!selectedPlaneId || !planes.has(selectedPlaneId)){ speak('Primero selecciona un avi√≥n.'); return; }
      if(n === null){ speak('No encontr√© el n√∫mero de velocidad.'); return; }
      const pl = planes.get(selectedPlaneId);
      pl.speed = n;
      recalcVelocity(pl);
      updatePlaneVisual(pl);
      speak(`Velocidad de ${pl.name} ajustada a ${n} nudos.`);
      return;
    }
    if(low.includes('rumbo') || low.includes('rumbo a') || low.includes('rumbo,') ){
      if(!selectedPlaneId || !planes.has(selectedPlaneId)){ speak('Primero selecciona un avi√≥n.'); return; }
      if(n === null){ speak('No encontr√© el n√∫mero de rumbo.'); return; }
      const pl = planes.get(selectedPlaneId);
      pl.heading = sanitizeHeading(n);
      recalcVelocity(pl);
      updatePlaneVisual(pl);
      speak(`Rumbo de ${pl.name} ajustado a ${n} grados.`);
      return;
    }
    if(low.includes('altitud') || low.includes('pies')){
      if(!selectedPlaneId || !planes.has(selectedPlaneId)){ speak('Primero selecciona un avi√≥n.'); return; }
      if(n === null){ speak('No encontr√© el n√∫mero de altitud.'); return; }
      const pl = planes.get(selectedPlaneId);
      pl.altitude = n;
      updatePlaneVisual(pl);
      speak(`Altitud de ${pl.name} ajustada a ${formatNumber(n)} pies.`);
      return;
    }

    speak('No entend√≠ el comando.');
  }

  // ========== CONTROLES UI ==========
  document.getElementById('btnStart').addEventListener('click', ()=>{ running = true; lastTime = null; requestAnimationFrame(loop); });
  document.getElementById('btnPause').addEventListener('click', ()=>{ running = false; });
  document.getElementById('btnMic').addEventListener('click', ()=>{ toggleListening(); });
  document.getElementById('btnTutorial').addEventListener('click', ()=>{ document.getElementById('modalTutorial').style.display = 'flex'; running = false; });
  document.getElementById('closeTutorial').addEventListener('click', ()=>{ document.getElementById('modalTutorial').style.display = 'none'; running = true; });
  document.getElementById('closeCollision').addEventListener('click', ()=>{ document.getElementById('modalCollision').style.display = 'none'; running = true; });

  // tecla G -> mic
  window.addEventListener('keydown', (ev)=>{ if(ev.key.toLowerCase()==='g'){ toggleListening(); } });

  // REMOVIDO: spawn slider listeners
  // spawnVal.textContent = spawnRateInput.value;
  // spawnRateInput.addEventListener('input', ()=>{ spawnVal.textContent = spawnRateInput.value; });

  // update counts
  function updateCounts(){ countRadarEl.textContent = planes.size; countLandedEl.textContent = landedCount; }

  // iniciar con el n√∫mero de aviones para tr√°fico leve (2 o 3, elegimos 3 para empezar)
  function init(){
      // Limpiar aviones existentes
      planes.forEach(p => p.el.remove());
      planes.clear();
      planeIdCounter = 1;
      landedCount = 0;
      updateCounts();
      selectPlane(null);
      
      // Crear 3 aviones iniciales
      for(let i=0;i<3;i++) createPlane();
  }
  
  // Iniciar la simulaci√≥n y el loop
  init();
  requestAnimationFrame(loop);

  // Exponer helpers para debugging (opcional)
  window.__tc = { planes, createPlane, selectPlane, recalcVelocity, updatePlaneVisual, calculateSpawnRate };

  </script>
</body>
</html>
